<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[springboot+mybatis+generator插件的使用]]></title>
    <url>%2F2019%2F02%2F05%2F2019-02-05-springboot%2Bmybatis%2Bgenerator%E6%8F%92%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[一 在pom文件中加入以下需要用到的jar包&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.3.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.baidu&lt;/groupId&gt; &lt;artifactId&gt;springboot-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springboot-demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.29&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!--mybatis 自动生成类--&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.30&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;mybatis generator&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;generate&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;!--防止反复生成--&gt; &lt;configuration&gt; &lt;!--允许移动生成的文件--&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;!--是否允许自动覆盖文件--&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;!--配置文件--&gt; &lt;configurationFile&gt; src/main/resources/mybatis-generator.xml &lt;/configurationFile&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;``` 加入两个配置文件：application.properties、mybatis-generator.xmlapplication.properties 是springboot默认使用的全局配置文件 ​``` #服务器启动端口 server.port=8087 #mapper映射xml文件的所在路径 mybatis.mapperLocations = classpath:mapping/*.xml spring.datasource.url=jdbc:mysql://127.0.0.1:3306/springbootdb spring.datasource.username=root spring.datasource.password=123456 #使用druid数据源 spring.datasource.type=com.alibaba.druid.pool.DruidDataSource spring.datasource.driverClassName=com.mysql.jdbc.Driver 三 mybatis-generator.xml:&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt; &lt;generatorConfiguration&gt; &lt;properties resource=&quot;application.properties&quot;&gt;&lt;/properties&gt; &lt;!--数据库驱动--&gt; &lt;!--&lt;classPathEntry location=&quot;mysql-connector-java-5.0.8-bin.jar&quot;/&gt;--&gt; &lt;context id=&quot;DB2Tables&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;commentGenerator&gt; &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;false&quot;/&gt; &lt;/commentGenerator&gt; &lt;!--数据库链接地址账号密码--&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://127.0.0.1:3306/springbootdb&quot; userId=&quot;root&quot; password=&quot;123456&quot;&gt; &lt;/jdbcConnection&gt; &lt;javaTypeResolver&gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt; &lt;/javaTypeResolver&gt; &lt;!--生成Model类存放位置--&gt; &lt;javaModelGenerator targetPackage=&quot;cn.edu.zut.domin&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt; &lt;/javaModelGenerator&gt; &lt;!--生成映射文件存放位置--&gt; &lt;sqlMapGenerator targetPackage=&quot;mapper&quot; targetProject=&quot;src/main/resources&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt; &lt;/sqlMapGenerator&gt; &lt;!--生成Dao类存放位置--&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;cn.edu.zut.dao&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt; &lt;/javaClientGenerator&gt; &lt;!--生成对应表及类名--&gt; &lt;table tableName=&quot;book&quot; domainObjectName=&quot;Book&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;&gt; &lt;/table&gt; &lt;table tableName=&quot;bookuser&quot; domainObjectName=&quot;User&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;&gt; &lt;/table&gt; &lt;/context&gt; &lt;/generatorConfiguration&gt; 四 运行插件Run→Edit Configurations…，然后选择maven，配置Command line Command line：mybatis-generator:generate然后运行这个maven 就可以了 五 测试所有配置完成后我们进行测试:```package cn.edu.zut;import cn.edu.zut.dao.UserMapper;import cn.edu.zut.domin.User;import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;@MapperScan(&quot;cn.edu.zut.dao&quot;)@SpringBootApplication(scanBasePackages = {&quot;cn.edu.zut&quot;})@RestControllerpublic class BootMybatis02Application { @Resource UserMapper userMapper; @RequestMapping(value = &quot;/&quot;, method = RequestMethod.GET) public String home() { System.out.println(&quot;hello word!&quot;); User user = userMapper.selectByPrimaryKey(1); if (user == null) { return &quot;用户对象不存在&quot;; } else { return user.getName(); } } public static void main (String[] args){ SpringApplication.run(BootMybatis02Application.class,args); }}]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Springboot+Thymeleaf]]></title>
    <url>%2F2018%2F10%2F20%2Fweb%E5%BC%80%E5%8F%91%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[一 自动配置原理一 这个场景springboot帮我们配置了什么？能不能够修改？能修改那些配置？能不能扩展？xxxAutoconfiguration:帮我们给容器中自动配置组件 xxxProperties:配置类来封装配置的内容 二 SpringBoot对静态资源的映射规则 所有 /webjars/** ，都去 classpath:/META-INF/resources/webjars/ 找资源； “/**” 访问当前项目的任何资源，都去（静态资源的文件夹）找映射 &quot;classpath:/META‐INF/resources/&quot;, &quot;classpath:/resources/&quot;, &quot;classpath:/static/&quot;, &quot;classpath:/public/&quot; &quot;/&quot;：当前项目的根路径 欢迎页； 静态资源文件夹下的所有index.html页面；被”/**”映射；localhost:8080/ 找index页面 所有的 **/favicon.ico 都是在静态资源文件下找； 三 模板引擎Thymeleafjsp/Thymeleaf/FreeMaker/VeloCity 1. 引入Thymeleaf&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; 默认2.16 &lt;/dependency&gt; 但是需要更新下Thymeleaf版本，添加 &lt;properties&gt; &lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;/thymeleaf.version&gt; &lt;!‐‐ 布局功能的支持程序 thymeleaf3主程序 layout2以上版本 ‐‐&gt; &lt;!‐‐ thymeleaf2 layout1‐‐&gt; &lt;thymeleaf‐layout‐dialect.version&gt;2.2.2&lt;/thymeleaf‐layout‐dialect.version&gt; &lt;/properties&gt; 2Thymeleaf使用只要我们把HTML页面放在classpath:/templates/xx.html， thymeleaf就能自动渲染 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF‐8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;成功！&lt;/h1&gt; &lt;!‐‐th:text 将div里面的文本内容设置为 ‐‐&gt; &lt;div th:text=&quot;${hello}&quot;&gt;这是显示欢迎信息&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; mvc的视图解析器/拦截器&lt;mvc: view-controller path=&quot;/hello&quot; view-name=&quot;success&quot;&gt; &lt;mvc interceptors&gt; &lt;mvc: interceptor&gt; &lt;mvc :mapping path=&quot;/hello&quot;&gt; &lt;bean&gt;&lt;/bean&gt; &lt;/mvc: interceptor&gt; &lt;/mvc interceptors&gt;]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot+Slf4]]></title>
    <url>%2F2018%2F10%2F14%2F%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[< blockquote/> 1.日志框架市面上常见的日志框架 日志门面（日志的抽象层） 日志实现 JCL SLF4J JBOSS-logging log4j log4j2 jul logback 左边选一个抽象层，右边来选一个实现 日志门面选SLF4J 日志实现选logback SpringBoot选用的是SLF4J和Logback 2. Slf4j1. Slf4j的使用开发的时候调用的是日志抽象层SLF4J里面的方法 使用的时候给系统里导入slf4j的jar和logback的实现jar import org.slf4j.Logger; import org.slf4j.LoggerFactory; public class HelloWorld { public static void main(String[] args) { Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info(&quot;Hello World&quot;); } } 深绿色的代表适配层，帮助我们使用除了logback以外的其他的日志实现 每一个日志的实现框架都有自己的配置文件。 slf4j同样如此，配置文件还是做成日志实现框架自己本身的配置文件 2. 遗留问题A系统(slf4j+logback): 其中也用到了Spring（commons-logging）,Hibernate(jboss-logging),Mybatis 能否把所有的框架统一日志记录，即使是别的框架也统一使用slf4j+logback呢 如何让系统中所有的日志统一到slf4j： 将系统中其他日志框架先排除出去 用中间包来替换原有的日志框架， 导入slf4j其他的实现 3. springBoot日志关系 SpringBoot使用它来做日志功能 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;version&gt;2.0.5.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; SpringBoot日志底层依赖关系 总结： SpringBoot的底层也是采用Slf4j+logback的方式来记录日志 SpringBoot也把其他日志都替换成了Slf4j 中间替换包 如果我们要引入其他框架，一定要把这个框架的默认日志依赖移除掉 ​ spring框架使用的是commons-logging; SpringBoot能自动适配所有的日志框架，且底层要使用slf4j+logback的方式来记录日志，引入其他框架的时候，只需要把这个框架依赖的默认日志框架移除掉即可 4.日志使用1. 默认配置 SpringBoot默认帮我们配好了日志 public class Springboot03LoggingApplicationTests { //记录器 Logger logger = LoggerFactory.getLogger(getClass()); @Test public void contextLoads() { Logger logger = LoggerFactory.getLogger(getClass()); //日志的级别，由低到高的顺序-----&gt; //可以调整需要输出得日志级，日志就只会在这个级别以后的高级别生效 logger.trace(&quot;这是trance日志&quot;); logger.debug(&quot;这是debug信息&quot;); //SpringBoot默认使用的是info级别 //没有指定级别的就用默认的级别，也叫root级别 logger.info(&quot;这是info日志&quot;); logger.warn(&quot;这是警告日志&quot;); logger.error(&quot;这是error日志&quot;); } application.properties中可以修改为 logging.level.cn.edu.zut=trace， 就会更改输出的级别了 logging.level.cn.edu.zut=trace # 生成log日志到指定位置,不指定位置在当前项目下生成 #logging.file=D:\\SpringBoot.log #logging.file=SpringBoot.log #在当前磁盘的根路径下创建文件夹，里面使用spring。log作为默认使用文件 logging.path=/Spring/log #在控制台输出的日志的格式 logging.pattern.console= #指定文件中日志输出的格式 logging.pattern.file= 默认的logback日志 C:\Users\Lenovo.m2\repository\org\springframework\boot\spring-boot\2.0.5.RELEASE\spring-boot-2.0.5.RELEASE.jar!\org\springframework\boot\logging\logback\base.xml &lt;included&gt; &lt;include resource=&quot;org/springframework/boot/logging/logback/defaults.xml&quot; /&gt; &lt;property name=&quot;LOG_FILE&quot; value=&quot;${LOG_FILE:-${LOG_PATH:-${LOG_TEMP:-${java.io.tmpdir:-/tmp}}}/spring.log}&quot;/&gt; &lt;include resource=&quot;org/springframework/boot/logging/logback/console-appender.xml&quot; /&gt; &lt;include resource=&quot;org/springframework/boot/logging/logback/file-appender.xml&quot; /&gt; &lt;root level=&quot;INFO&quot;&gt; &lt;appender-ref ref=&quot;CONSOLE&quot; /&gt; &lt;appender-ref ref=&quot;FILE&quot; /&gt; &lt;/root&gt; &lt;/included&gt; 起的xml文件名叫 logback.xml ：就直接被日志框架识别了 logback-spring.xml:日志框架就不能直接加载日志的配置项，由springBoot解析日志配置，可以使用springboot的高级profile功能]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yaml+配置类]]></title>
    <url>%2F2018%2F10%2F14%2FYaml-%E9%85%8D%E7%BD%AE%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[一 使用SpringInitializer快速创建SpringBoot项目 Resources文件夹中目录结构： templates : 保存所有的模板页面；（SpringBoot默认jar包使用嵌入式的Tomcat，默认不支持jsp页面）；可以使用模板引擎（freemarker，thymeleaf） application.properties ： Spring应用的配置文件，可以修改一些默认设置 二配置文件1 SpringBoot默认使用一个全局的配置文件，配置的文件名是固定的 application.properties application.yml YAML: 是/不是一个标记语言 标记语言： ​ 以前的配置文件，大多是xxx.xml文件 ​ YAMl： 以数据为中心，比jsaon，xml更适合配置文件 server: port: 8081 XMl: &lt;server&gt; &lt;port&gt;8081&lt;/port&gt; &lt;/server&gt; 2 YAML语法 基本语法 k: v 表示一对键值对（空格必须有） 以空格的缩进来控制层级关系；只要左对齐的一列数据都是同一个层级的 server: port: 8081 path: /hello 属性和值也是大小写敏感 值的写法 字面量：普通的值（数字，字符串，布尔） k: v 字面量直接写 ​ 字符串默认不需要加“”和‘’ ​ “ ”：不会转义字符串里面的特殊字符； 特殊字符会作为本身想表示的意思 ​ name: “zhangsan \n lisi” 输出 ：zhangsan 换行 lisi ​ ‘ ‘ : ​ name: ‘zhangsan \n lisi” 输出 ：zhangsan \n lisi 对象,map(属性和值) （键值对）； k:v 在下一行写对象的属性和值的关系；注意缩进 ​ 对象还是k:v ​ friends： lastName: zhangsan agea: 20 行内写法： frinends: {lastName: zahngsan,age: 18} 数据（list，Set）； ​ 用-值表示数组中的一个元素 pets: - cat - dog - pig 行内写法 pets: [cat,dog,pig] 3 @Value（）获取值和@ConfigurationProperties()获取值区别 @ConfigurationProperties() @Value（） 功能上 批量注入配置文件中的属性（prefix=“ ”） 一个个指定 松散语法（lastName/last-Name） 支持 不支持 spEl 不支持 支持 JSR303校验 支持 不支持 复杂类型封装（Map、list） 支持 不支持 spEl语法：(Spring表达式语言) 例 &lt;bean class=&quot;person&quot;&gt; &lt;property name=&quot;lastName&quot; value=&quot;字面量/$(key)从环境变量，配置文件中获取值/#{spEL}&quot;&gt; &lt;/property&gt; &lt;/bean&gt; JSR303校验； 例 @Validated public class Person { //lastName必须填成邮箱格式 @Email private String lastName; 3.1总结：​ 如果只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value（） ​ 例 @RestController public class HelloController { @Value(&quot;${person.lastName}&quot;) private String name; @RequestMapping(&quot;/hello&quot;) public String sayHello(){ return &quot;Hello&quot;+name; } } ​ 如果我们专门编写了javabean来和配置文件映射（用数据库了），就直接使用@ConfigurationProperties ​ 4. @PropertySource和@ImportSource@PropertySource：加载指定的配置文件(把指定的配置文件内容提取出来，新建一个person.properties) @PropertySource(value = {&quot;classpath:person.properties&quot;}) @Component @ConfigurationProperties(prefix = &quot;person&quot;) //@Validated public class Person { ​ @imporResource： 导入Spring的配置文件，让配置文件里的内容生效 SpringBoot里面没有Spring的配置文件，我们自己编写的配置文件beans.xml也不能自动识别 想让spring的配置文件生效，加载进来； @imporResource 标注在主配置类上 @ImportResource(locations = {&quot;classpath:beans.xml&quot;}) @SpringBootApplication public class Springboot03Application { public static void main(String[] args) { SpringApplication.run(Springboot03Application.class, args); } 功能：导入Spring的配置文件让其生效 然而不推荐使用，SpringBoot推荐给容器中添加组件的方式是使用全注解的方式 以前的Spring配置文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;HelloService&quot; class=&quot;cn.edu.zut.service.HelloService&quot;&gt; &lt;/bean&gt; &lt;/beans&gt; 5配置类======Spring配置文件用@bean /* 指明当前类是一个配置类，替代之前的Spring配置文件 在配置文件中使用&lt;bean&gt;&lt;/bean&gt;标签添加组件 */ @Configuration public class MyConfig { //将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名 @Bean &lt;&lt;--------------------------------- public HelloService helloService(){ System.out.println(&quot;配置类@Bean给容器中添加组件了&quot;); return new HelloService(); } } 6 配置文件占位符person.lastName=张三${random.uuid} person.age=${random.int} person.dog.name=${person.hello:hello}_dog 拼接字符串，占位符获取之前配置的值，若果没有，用：指定默认值 7 profile7.1 多Profile文件​ 例如：又新建了application-dev.properties，application-produce.properties，分别指定了不同的端口号 ​ 我们在主配置文件编写的时候，文件名可以是application-{profile}.properties/yml ​ 默认使用application.properties的配置 7.2 yml支持多文档块形式server: port: 8081 spring: profiles: active: produce --- server: port: 8082 spring: profiles: produce --- server: port: 8083 spring: profiles: dev 7.3激活指定Profile 在默认配置文件application.properties中指定要激活哪个配置 例 spring.profiles.active=produce 命令行 --spring.profiles.active=produce 8 自动配置配置文件能配置的属性spring官网最后一章附录 commom applictions]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo更换电脑]]></title>
    <url>%2F2018%2F09%2F05%2FHexo%E6%9B%B4%E6%8D%A2%E7%94%B5%E8%84%91%2F</url>
    <content type="text"><![CDATA[# 前言： Hexo博客源文件放在本地，更换电脑怎么更新博客？ 可以上传到github，创建分支，换电脑后克隆下来，也可以按照本文所说方法1.将你原来电脑上已经配置好并生成的hexo目录拷到新电脑上，无需拷全部，只拷如下几个目录： _config.yml package.json scaffolds/ source/ themes/ 将这些目录放到一个目录下，如：hexo／ 2.在你的新电脑上首先配置hexo环境：安装Node.js3.安装hexo，执行命令： npm install -g hexo 4.安装好之后，进入hexo／目录5.模块安装，执行命令： npm install npm install hexo-deployer-git --save npm install hexo-generator-feed --save npm install hexo-generator-sitemap --save 6.部署，执行命令： hexo g hexo deploy]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot学习笔记-Helloworld]]></title>
    <url>%2F2018%2F09%2F05%2FSpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Helloworld%2F</url>
    <content type="text"><![CDATA[HelloWorld探究 # 前言: SpringBoot学习笔记，仅为记录之用，理解不当之处尽情指出 Spring官网： ctrl +home 首页 ctrl+f 查找 starters 1. Pom文件1. 父项目&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.3.RELEASE&lt;/version&gt; &lt;/parent&gt; 他的父项目是 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.0.3.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt; &lt;/parent&gt; 他来真正管理Spring Boot应用里的所有依赖版本 Spring Boot的版本仲裁中心 以后我们导入依赖默认是不需要写版本（没有在dependencies里面管理的自然需要写版本号） 2. 导入的依赖&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; spring-boot-starter-web spring-boot-starter :SpringBoot场景启动器；帮我们导入了web模块正常运行所依赖的组件 SpringBoot将所有的功能场景都抽取出来，做成一个个的starters（启动器）。只需要在项目里导入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器 2. 主程序类，主入口类import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; /* * @SpringBootApplication 标注这是一个主程序类。说明这是一个springboot应用 * */ @SpringBootApplication public class HelloWorldMainApplication { public static void main(String[] args) { //Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); } } 2.1 @SpringBootApplication : 标注在某个类上，说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用 @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) }) public @interface SpringBootApplication { 一直往注解里面点 2.1.1 @SpringBootConfiguration： 标注在某个类上，表示这是一个Spring Boot的配置类——-》SpringBoot定义的注解 Configuration： 配置类上来标注这个注解——》spring定义的注解 配置类—-配置文件 @Component：说明配置类也是容器中的一个组件 2.1.2@EnableAutoConfiguration 开启自动配置功能 ​ 以前需要配置的东西，SpringBoot帮我们自动配置 @EnableAutoConfiguration告诉SpringBoot开启自动配置功能，这样自动配置功能才能生效 @AutoConfigurationPackage @Import(AutoConfigurationImportSelector.class) public @interface EnableAutoConfiguration { 2.1.2.1 AutoConfigurationPackage：自动配置包 2.1.2.2@Import(AutoConfigurationImportSelector.class):** Spring的底层注解@import，给容器中导入一个组件；导入的组件由AutoConfigurationImportSelector.class 再进入这个class register(registry, new PackageImport(metadata).getPackageName());在这一行打断点调试，右键Evaluate发现会得到主配置包名 说明 AutoConfigurationPackage：作用是将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器 2.1.2.2@Import(AutoConfigurationImportSelector.class详解 给容器中导入组件？ 导入哪些组件的选择器 将所有需要导入的组件以全类名的方式返回；这些组件机会返回到容器·中 会给容器中导入非常多的自动配置类（XXAutoConfigration）;就是给容器中导入这个场景需要的所有组件，并配置好这些组件 有了自动配置类，就免去了手动编写配置，注入功能组件等工作 @SpringBootApplication–&gt;@EnableAutoConfiguration-&gt;@Import(AutoConfigurationImportSelector.class)—-&gt; List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes); getCandidateConfigurations—-&gt;SpringFactoriesLoader.loadFactoryNames( getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader()); @EnableAutoConfiguration-&gt;@Import(AutoConfigurationImportSelector.class)—-&gt; List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);–&gt;getCandidateConfigurations–&gt;loadFactoryNames 同页有个META-INF/spring.factories”) SpringBoot启动的时候从META-INF/spring.factories”中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效了，给我们进行自动配置工作，以前我们需要自己配置的东西，自动配置类全都帮我们配置了。 所有的配置类都放在springbootAutoConfigurer包下了， J2EE的整体整合解决方案和自动配置都在 spring-boot-autoconfigure-2.0.3.RELEASE.jar里了]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git&GitHub从安装到使用]]></title>
    <url>%2F2018%2F08%2F09%2FGit%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[一 小白安装Terry和你一起从新手出发,Git世界探索之路从现在开始目的：通过git管理GitHub托管项目代码下载：（git是一个软件，分32位，64位）安装：注意这两步，其他的都选next检验：鼠标在桌面右击，出现两个Git Gui here 和Git Bash here ,说明安装成功 二 Git最核心也是最基础的几个概念2.1 Git 工作区域：代码提交流程【3—–》2——–》1】 1 Git Repository（Git 仓库）： 最终确定的文件保存到仓库，成为一个新的版本，并且对他人可见 2 暂存区 ：暂存已经修改的文件，最后统一提交到git仓库中 3 Working Dictionary (工作区） : 添加，编辑，修改等动作 2.2 不同区的来回跑2.2.1工作区—–》暂存区git status （查看文件在哪个区）git add hello.java 2.2.2暂存区——》仓库git statusgit commit -m “提交描述” 仓库git status 三 Git在本地的操作3.1 基本信息设置用户名和邮箱是唯一的，当你fork一个项目，点进去查看时，会看到最近提交Pull Requests的人的信息，写错了就是别人了设置用户名git config –global user.name ‘TerryLovesSmiles’设置邮箱git config –global user.email ‘1164402695@qq.com’注意： 该设置在GitHub主页显示谁提交了该文件 3.2 初始化一个新的Git仓库创建文件夹 mkdir test在文件内初始化git(创建git仓库 cd test pwd git init (会生成.git隐藏文件（存储仓库的本地信息的），看不到的话，就设置下显示隐藏文件喽) 3.3 向仓库中添加文件（工作区—–》暂存区—》git 仓库 touch a1.java —–&gt;新建一个文件 git add a1.javagit commit -m “add a1.java” 3.4 修改文件(修改过后，再次重新add到暂存区,commit) vi test 编辑cat test 显示出来文件内的信息git statusgit add test 暂存区的a1.java是蓝色的git commit test -m “modify test” 3.5 删除文件rm -rf a1.javagit rm a1.javagit commit a1.java -m “rm a1.java” 4 Git远程仓库###4.1 作用：备份。 实现代码的共享。 工作区—add–》暂存区—commit—》Git仓库（本地）–push—–》Git远程仓库 git congig –list 查看配置信息 4.2 Git克隆目的 将远程仓库（github对应的项目）复制到本地代码 ： git clone 仓库地址…….git push (会报错 即让你输入用户名和密码) 办法将 [remote “origin”]​ url = https://github.com/用户名/仓库名.git改为 [remote “origin”]​ url = https://用户名:密码@github.com/用户名/仓库名.git]]></content>
      <categories>
        <category>Git&amp;GitHub</category>
      </categories>
      <tags>
        <tag>Git小白篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo个性优化大全]]></title>
    <url>%2F2018%2F08%2F09%2FHexo%E4%B8%AA%E6%80%A7%E4%BC%98%E5%8C%96%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[< blockquote/> ## 万丈高楼平地起，昨天我们把Hexo博客搭成了自己的小窝，那么今天！！！ Terry告诉你：史上最全的next主题优化教程来了！ 来吧！和Terry一起把Hexo从小木屋搭成小洋楼！！！ 第一步，基本功能的完善来Next的使用中文官网，照着做，一步一步来，没有比这更详细的基础搭配了 [Next使用文档]http://theme-next.iissnan.com/: 第二步，个性化优化这位老哥的Hexo优化博客，被网上疯狂转载，我的博客优化70%基本都来源于这篇博客 超详细进阶优化 第三步 ，超全的进阶优化你再也不用费心思到处找了，都在这啦！！！ 看到文章左边的分享按钮了吗？他来源于这 看到文章下边的评论系统了吗？你可以参考这 看到Hexo左下角的音乐播放了吗？来。兄dei看这 主页文章，能我点阅读全文再展开吗？嘿嘿，可以呀 背景图片看起来，哎呀，不错吆！来这 Hexo-admin后台管理，任何地方都可以更新博客了来吧 第四步 兄dei们，你们看着办吧Terry利用闲暇基本所有时间整理了三天，现在全在这了，空荡荡的看完就走，你的良心不会痛吗。。。（微笑脸）]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+GitPages--从0搭建，再也不羡慕别人了！]]></title>
    <url>%2F2018%2F08%2F08%2FHexo-GitPages-%E4%BB%8E0%E6%90%AD%E5%BB%BA%E5%88%B0%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[为什么会想到要自己搭博客呢？ 一方面一直对传说中的自己搭一个博客充满了敬佩和好奇，另一方面对别人自己好看的博客真的是羡慕呀！再加上实在无法忍受csdn等老牌博客网站无处不在的广告突袭。。。受不了，那就搭喽！ 搭建心得 搭的时候，心态初期感觉难如登天，因为教程太多了，有些常识大佬不提，可对自己来说，那个真的不是常识呀！QAQ 。。。老是报各种错误。。 心态中后期，发现报的错都是普遍的常见错。。。网上解决方法太多了，真是爱死度娘了 好了，话不多说，正式开始​ 二 用Hexo在本地搭建一个博客安装Hexo 1.下载安装nodejs http://nodejs.cn/ 傻瓜式安装 2. 下载安装git https://git-scm.com/downloads 傻瓜式安装 3. 在gitBash命令行使用npm安装Hexo npm install -g hexo-cli //在gitBash命令里快速开始 1.在桌面新建个文件夹blog，在GitBash里进入这个文件夹,输入 注意：blog是自己建的空白项目文件名 hexo i blog //init的缩写 cd blog //切换到站点根目录 hexo g //generetor的缩写 hexo s //server的缩写 2. 打开浏览器输入localhost:4000查看： 这个是Hexo的默认博客主题。看到这个说明在本地已经搭建成功了 选择主题-Next 在站点根目录输入 git clone https://github.com/iissnan/hexo-theme-next themes/next 完成后，打开站点配置文件， 找到theme 字段，把landscape更改为next 在终端输入hexo clean //清除缓存 hexo g //重新生成代码 hexo s //部署到本地 //然后打开浏览器访问 localhost:4000 查看效果 ![image](https://note.youdao.com/yws/api/personal/file/C808C8261FE2459D9B925CEF556BB83B?method=download&amp;shareKey=6cefff581dd31aed946d8753f17599be) nexT主题有三种选择，这个只是最简洁的一种，我们选择最好看的那个。 Muse -默认Scheme，这是NexT最初的版本，黑白主调，大量留白 Mist - Muse的紧凑版本，整洁有序的单栏外观 Pisces -双栏Scheme，小家碧玉似的清新 4. 配置nexT ctrl+f 搜素scheme , 选择pisces 然后重新clean，generator，查看效果: ![image](https://note.youdao.com/yws/api/personal/file/FB34B886E1D44111A1210ABDD1790D89?method=download&amp;shareKey=7bbef245bcf4d31f0eb276512107de7c) ## 三 将本地博客上传到GitHub 因为我们想要的是通过网址访问，所以接下来还要搭到GitHub上 具体的可以看 [这个博客](https://blog.csdn.net/Hoshea_chx/article/details/78826689) ## 四 注意！！！ 在修改Hexo的站点文件时 冒号的后面一定一定一定要有一个空格！！（大坑） ## 五 发布你的第一篇博客 根目录下输入： hexo new “postName” //hexo n 也可以 //你自己的博客名称，名为postName.md的文件会建在目 //录/blog/source/_posts下。 文章编辑完成后，终端在根目录文件夹下，执行如下命令来发布: hexo g //生成静态页面hexo d //发布``` 六 后记这个只是最简单的博客的搭建，相当于盖房子。盖了一个小木屋，成长为参天大树还需要进一步个性化配置]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo搭建</tag>
      </tags>
  </entry>
</search>
